<!DOCTYPE HTML>
<html>
<head>
    <title>Programming Sample: Satoyama Dice AI - Robert Gervais Portfolio</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="assets/css/main.css" />
    <noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
</head>
<body class="is-preload">

    <div id="wrapper">

        <header id="header">
            <a href="index.html" class="logo"><strong>Robert Gervais</strong> <span>Portfolio</span></a>
            <nav>
                <a href="#menu">Menu</a>
            </nav>
        </header>

        <nav id="menu">
            <ul class="links">
                <li><a href="index.html">Home</a></li>
                <li><a href="landing.html">Samples</a></li>
                <li><a href="programming-samples-overview.html">Programming Samples</a></li>
            </ul>
            <ul class="actions stacked">
                <li><a href="robert-gervais-resume.pdf" class="button primary fit" target="_blank">View Resume (PDF)</a></li>
            </ul>
        </nav>

        <div id="main" class="alt">

            <section id="one">
                <div class="inner">
                    <header class="major">
                        <h1>Satoyama Dice</h1>
                    </header>

                    <span class="image main"><img src="images/satoyama-dice-by-robert-gervais.jpg" alt="Image: Robert Gervais" /></span>

                    <h2>Project Goal</h2>
                    <p>This sample demonstrates the AI architecture for my LÖVE2D game, "Satoyama Dice." The primary goal was to create a challenging and fair CPU opponent that could analyze the 6x6 Sudoku-like game board, make strategic decisions, and use the same game mechanics available to the player (placing dice, using items, re-rolling).</p>
                    <p><strong>Tools/Languages:</strong> <strong>LÖVE2D (Lua)</strong>, <strong>State Machines</strong>, <strong>Heuristic-Based Decision Making</strong>, and the <strong>Strategy Pattern</strong>.</p>

                    <h2>Technical Highlights</h2>
                    <ul>
                        <li><strong>Decoupled State Machine:</strong> The AI (<code>sd_ai.lua</code>) runs as a self-contained module with its own state (e.g., <code>isTurn</code>, <code>thinkingTime</code>, <code>pendingAction</code>). It's driven by the main game state (<code>sd_satoplay.lua</code>) but doesn't tangle with its logic.</li>
                        <li><strong>Character State Stack:</strong> The Saikoro character (<code>sd_saikoro.lua</code>) uses its own state stack to manage animations, allowing high-priority expressions (like smiling or frowning) to temporarily override the base "idle" state.</li>
                        <li><strong>Clean Interface:</strong> The AI requests read-only game state via accessor functions (e.g., <code>playState.getGrid()</code>, <code>playState.getDiceValues()</code>) and sends its chosen move as a simple data table (e.g., <code>{type = "PLACE_ON_GRID", ...}</code>). The game state then executes the action via <code>playState.performAiAction(action)</code>.</li>
                        <li><strong>Pluggable Strategy Pattern:</strong> The AI's "brain" is not hard-coded. It delegates its decision to a <code>currentStrategy</code> module (<code>aiModule.currentStrategy:execute(gameState)</code>), allowing different AI "personalities" (e.g., Beginner, Aggressive, Heuristic) to be easily swapped.</li>
                        <li><strong>Tiered Heuristic Logic:</strong> The core solver (<code>sd_ai_helper.lua</code>) uses a 3-tier heuristic to find strategic moves, mimicking human problem-solving: it first looks for "Naked Singles," then "Hidden Singles," and finally falls back to a brute-force correct move if no simple strategy is found.</li>
                        <li><strong>"Thought" Visualization:</strong> The AI renders its analysis (potential moves, scores) to a separate LÖVE canvas (<code>aiModule.thoughtCanvas</code>). This provides an excellent debugging tool and a player-facing "show thoughts" feature.</li>
                        <li><strong>Knowledge & Memory:</strong> The AI reacts to game events, such as player hints, and stores that information in a temporary "memory" (<code>revealedHintCells</code>, <code>hintKnowledgeTimer</code>) to make smarter short-term decisions.</li>
                    </ul>

                    <h2>Code Snippets</h2>
                    <p>The AI and character systems are split into main parts: the character's animation state, the AI "brain" (state machine), the game state "actuator" (interface), and the "solver" (heuristic logic). Below are key snippets from each.</p>

                    <h3>Snippet 1: Saikoro Character Expression & State</h3>
                    <p>This snippet from <code>sd_saikoro.lua</code> demonstrates the character's animation system. To handle expressions like smiling or frowning, I implemented a simple state stack. When the game triggers a <code>smile()</code> or <code>frown()</code> action (in response to a correct or incorrect move), it pushes a new state (e.g., <code>"smiling"</code>) onto the stack. The character's <code>update</code> loop then processes logic for the <em>top-most</em> state. This allows high-priority expressions to interrupt the base "idle" state (like blinking or pupil tracking) and then automatically pop themselves off the stack when their animation timer expires, cleanly returning to the previous state.</p>
                    <pre><code>-- Excerpt from sd_saikoro.lua (Character Animation State)

----------------------------------------
-- STATE STACK HELPERS
----------------------------------------

function Saikoro:getCurrentState()
    return self.state.stack[#self.state.stack]
end

function Saikoro:pushState(state)
    -- Don't push the same state twice
    if self:getCurrentState() == state then return end
    table.insert(self.state.stack, state)
end

function Saikoro:popState(state)
    -- If a state is provided, only pop if it's the current one
    if state and self:getCurrentState() ~= state then return end
    
    if #self.state.stack > 1 then -- Never pop the base "idle" state
        table.remove(self.state.stack)
    end
end

----------------------------------------
-- UPDATE (Relevant States)
----------------------------------------

function Saikoro:update(dt, mouseX, mouseY)
    -- ... (update animated values) ...

    local currentState = self:getCurrentState()

    -- Process logic based on the *top* of the state stack
    if currentState == "frowning" then
        self.state.mouth.sadScale = self.state.mouth.sadScale - dt
        if self.state.mouth.sadScale < 0 then
            self:popState("frowning") -- Frown timer done
            self:pushState("decaying") -- Enter decay state
            
            -- Animate mouth back to neutral...
            self.state.mouth.arcRadiusAnim:easeTo(0, 0.15, easeOutCubic)
            self.state.mouth.rectHeightAnim:easeTo(self.size * 0.05, 0.2, easeOutCubic, function() 
                self:popState("decaying") 
            end)
        end
        
    elseif currentState == "smiling" then
        self.state.mouth.happyScale = self.state.mouth.happyScale - dt
        if self.state.mouth.happyScale < 0 then
            self:popState("smiling") -- Smile timer done
            self:pushState("decaying") -- Enter decay state
            
            -- Animate mouth back to neutral...
            local speed = (self.personality == "sleepy") and 0.8 or 0.2
            self.state.mouth.rectHeightAnim:easeTo(self.size * 0.05, speed, easeOutCubic, function() self:popState("decaying") end)
            self.state.mouth.arcRadiusAnim:easeTo(0, speed, easeOutCubic)
        end
    
    -- ... (other states like idle, hinting) ...
    
    -- ... (Shared Logic like Blinking/Pupils) ...
end

----------------------------------------
-- SAIKORO'S PUBLIC API (State Pushers)
----------------------------------------

function Saikoro:smile(force)
    local currentState = self:getCurrentState()
    -- Allow smile to override idle/hinting
    if not force and (currentState ~= "idle" and currentState ~= "hinting") then return end
    
    self:clearLowPriorityStates() -- Removes "hinting", etc.
    self:pushState("smiling")
    
    self.state.mouth.happyScale = 1.5 -- Smile for 1.5 seconds
    self.state.mouth.rectHeightAnim:easeTo(0, 0.15, easeOutCubic)
    self.state.mouth.arcRadiusAnim:easeTo((self.size * 0.4) / 2, 0.2, easeOutBack)
end

function Saikoro:frown()
    local currentState = self:getCurrentState()
    -- Only allow frown to override idle/hinting
    if currentState ~= "idle" and currentState ~= "hinting" then return end
    
    self:clearLowPriorityStates()
    self:pushState("frowning")

    self.state.mouth.sadScale = 2.0 -- Frown for 2 seconds
    self.state.mouth.rectHeightAnim:easeTo(0, 0.15, easeOutCubic)
    self.state.mouth.arcRadiusAnim:easeTo(-(self.size * 0.4) / 2, 0.2, easeOutBack)
end</code></pre>

                    <h3>Snippet 2: The AI Brain's Turn</h3>
                    <p>This function is the entry point for the AI's turn. It gathers all necessary data from the game, delegates the <em>decision</em> to its strategy module, and then stores the resulting <code>chosenAction</code> to be executed after a "thinking" delay.</p>
                    <pre><code>-- Excerpt from sd_ai.lua
function aiModule.startTurn(playState, cellSize)
    aiModule.isTurn = true
    aiModule.thinkingTime = 1.5 -- Simulate "thinking"
    aiModule.showThoughts = true

    -- Get all necessary game state information
    local gameState = {
        grid = playState.getGrid(),
        diceValues = playState.getDiceValues(),
        hint = playState.getHint(),
        solution = playState.getSolution(),
        revealedCells = aiModule.revealedHintCells,
        cpuBombs = playState.getCPUBombs(),
        cpuBullseyes = playState.getCPUBullseyes(),
        canReroll = playState.getCanRerollCPU()
    }

    -- DELEGATE the decision to the current strategy
    local chosenAction, moveVisuals = aiModule.currentStrategy:execute(gameState)
    aiModule.pendingAction = chosenAction -- Store the action

    -- Draw the AI's thoughts to the canvas (simplified)
    love.graphics.setCanvas(aiModule.thoughtCanvas)
    love.graphics.clear()
    if moveVisuals then
        -- (Logic to draw scores and highlights on the canvas)
    end
    love.graphics.setCanvas()
end</code></pre>

                    <h3>Snippet 3: The Game's AI Interface</h3>
                    <p>This function in the main play state file receives the simple action table from the AI module. It acts as the "actuator," translating the AI's intention into actual game state changes, like placing a tile or re-rolling.</p>
                    <pre><code>-- Excerpt from sd_satoplay.lua (AI Interface)
function satoPlayState.performAiAction(action)
    if not action then
        turnState.isCPUTurn, turnState.cpuTurnPhase = false, 'none'
        return
    end

    if action.type == "PLACE_ON_GRID" then
        placeTileOnGrid(action.row, action.col, action.diceValue, true)
        turnState.isCPUTurn, turnState.cpuTurnPhase = false, 'none'
    
    elseif action.type == "SPEND_HINT" then
        local revealedCells = {}
        for r = 1, GRID_SIZE do
            for c = 1, GRID_SIZE do
                if not gridTiles[r][c] and solution[r][c] == action.value then
                    table.insert(revealedCells, {row = r, col = c})
                end
            end
        end
        
        -- Give the AI "knowledge" of the revealed cells
        aiModule.registerHintKnowledge(revealedCells, 15)
        cpuHintState.grid = {nil, nil}
        turnState.isCPUTurn, turnState.cpuTurnPhase = false, 'none'
    
    elseif action.type == "RE-ROLL" then
        if turnState.canReroll_cpu then
            -- (Roll dice logic...)
            turnState.cpuTurnPhase = 'rolling'
            return true -- Tell the update loop the turn continues
        end
    
    -- (Other actions like USE_BOMB, CREATE_BULLSEYE, etc.)
    end
end</code></pre>

                    <h3>Snippet 4: The 3-Tier Heuristic Solver</h3>
                    <p>This is the core "solver" logic used by the Heuristic strategy. It demonstrates a tiered approach to finding a move, starting with the simplest (and most human-like) Sudoku strategies before resorting to a brute-force solution.</p>
                    <pre><code>-- Excerpt from sd_ai_helper.lua
function aiHelper.getStrategicHint(grid, solution)
    -- Tier 1: Find "Naked Single" (only choice in a row/col/box).
    local hint = findOnlyChoice(grid, solution)
    if hint then
        return hint
    end

    -- Tier 2: Find "Hidden Single" (last remaining cell for a number).
    hint = findLastRemaining(grid, solution)
    if hint then
        return hint
    end

    -- Tier 3: If all strategic checks fail, find any correct move.
    hint = findAnyCorrectMove(grid, solution)
    if hint then
        return hint
    end

    return nil
end</code></pre>

                    <section id="two">
                        <div class="inner">
                            <header class="major">
                                <h2>Saikoro Character Video</h2>
                            </header>
                            <p style="margin-top: 2em;">Watch how Saikoro reacts to the player's actions.</p>
                            <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; background: #000;">
                                <iframe style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: 0;"
                                        src="https://www.youtube.com/embed/2Dm8uO3Tmck?si=A3HGpwz8LYkPzeon"
                                        title="YouTube video player"
                                        frameborder="0"
                                        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                                        allowfullscreen>
                                </iframe>
                            </div>
                            <p class="video-caption">Video and image: Chuckanut Games</p>
                        </div>
                    </section>

                    <h2>Conclusion</h2>
                    <p>This architecture proved to be robust, maintainable, and easily extensible. By separating the character's state, the AI's decision-making logic, and the game-world interface, I could add new behaviors (like new items or character expressions) without refactoring the entire system. View the algorithm here.</p>
                    <ul class="actions">
                        <li><a href="samples/robert-gervais-ai-helper-algorithm.pdf" class="button primary icon solid fa-download">View Algorithm (PDF)</a></li>
                    </ul>
                    <ul class="actions">
                        <li><a href="programming-samples-overview.html" class="button">Back to Programming Samples</a></li>
                    </ul>
                </div>
            </section>

        </div>

        <footer id="footer">
            <div class="inner">
                <ul class="icons">
                    <li><a href="https://www.linkedin.com/in/robert-gervais-358928249/" class="icon brands alt fa-linkedin-in"><span class="label">LinkedIn</span></a></li>
                    <li><a href="https://x.com/RobertGDev" class="icon brands alt fa-twitter"><span class="label">Twitter</span></a></li>
                </ul>
                <ul class="copyright">
                    <li>&copy; Robert Gervais</li>
                    <li>Design: <a href="https://html5.up.net">HTML5 UP</a></li>
                </ul>
            </div>
        </footer>

    </div>

    <script src="assets/js/jquery.min.js"></script>
    <script src="assets/js/jquery.scrolly.min.js"></script>
    <script src="assets/js/jquery.scrollex.min.js"></script>
    <script src="assets/js/browser.min.js"></script>
    <script src="assets/js/breakpoints.min.js"></script>
    <script src="assets/js/util.js"></script>
    <script src="assets/js/main.js"></script>

</body>
</html>